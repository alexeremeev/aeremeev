- Анализ методов ArrayList:
    1. Add. Время выполнения - О(1), т.к. arraylist основан на массиве, куда вставка осуществляется по индексу
    за фисксированное время. В худщем случае, когда изначального размера списка не хватит для вставки элемента, в
    связи с расширением (созданием нового массива и копированием в него старого) время будет O(n).
    2. Remove. Если метод выполняется по индексу объекта в списке, то O(1). Если по самому объекту, то нужно идти
    последовательно по всему списку и в таком случае время O(n).
    3. Replace(Set). Т.к. мы обращается в методе по индексу к заменяемому элементу, то время работы О(1).
    4. Search by index. Доступ к объекту по индексу - O(1).

- Анализ методов LinkedList:
    1. Add. Считая, что вставка происходит всегда в конец списка, время работы 0(1), т.к. нужно добавить всего одну
    ноду списка к последней и указать на нее, как на хвост списка.
    2. Remove. В случае удаления по индексу или по объекту время работы одинаковое - О(n). Требуется пройти по всему
    списку, чтобы получить с помощью счетчика индекс объекта, а также сравнить его с переданным в другом случае.
    3. Replace(Set). Требуется пройти по всему списку, чтобы получить индекс, время - O(n).
    4. Search by index. Как и в предыдущих случаях - время O(n).

- Анализ методов HashMap:
    1. Add. Т.к. HashMap основана на бакетах и вычислении хэш функциий от объектов, время добавления О(1). В случае
    возникновения коллизии при подании 2ъ объектов в один бакет, создается связный список и объект доваляется в конец
    списка, в этом редком случае время для этого бакета О(n). В JDK 8, при прохождении порога 8 элементов на бакет, бакет
    преобразуется в TreeMap c временем поиска/вставки O(log(n)).
    2. Remove. В среднем - O(1), т.к. вычисляя хэш-фунцию от объекта и получаем бакет, в котором он хранится. В худших,
    опять же O(n) и O(log(n)) от размера бакета.
    3. Replace(Set). Так же, как и в предыдущих случаях. При остутствии коллизий - О(1),
    иначе O(n) или O(log(n)) от размера бакета.
    4. Search by index. Так же, как и в предыдущих случаях. При остутствии коллизий - О(1),
    иначе O(n) или O(log(n)) от размера бакета.

- Анализ методов TreeMap:
    1. Add. TreeMap построен на самобаласирующемся красно-черном дереве. В данному случае ключ должен реализовывать
    интерфейс Comparable. Для добавления дерево сравнивает объект с головной нодой и определяет, в какую половину его
    направить - в большую или меньшую. Такая операция произоводится для всех последующих дочерних нод, каждый раз деля
    дерево пополам. В этом случае получаем логарифмическую зависимость O(log(n)).
    2. Remove. Так же, как и предыдущем случае O(log(n)).
    3. Replace(Set). Так же, как и предыдущем случае O(log(n)).
    4. Search by index. Так же, как и предыдущем случае O(log(n)).